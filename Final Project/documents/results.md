# Report

## Output and Correctness of each Algorithm

### Data Parsing/ Correction

- Initially the data parsing and correction part of the project only parsed airports that had a null value for the IATA. This worked fine until it came time to implement the graph structure. The graph structure was created using a constructor that took the airports and routes files as inputs and populated the airports and adjacency lists accordingly using a comma as the delimiter. An issue that quickly arose was that whenever an airport attribute such as name or city included a comma within the quotes the comma delimiter would seperate this attribute. This would cause an additional (fake) attribute to be created which disrupted the parsing process of each data sample. This was an unexpected behavior that was noted and eventaully corrected in the code.

### Breadth-First Search Traversal

- The implementation of the Breadth-First Search Traversal went as expected. We utilized a queue which gave us the desired time comlexity of O(E+N) where E is the number of routes and N is the number of airports. We also achieved the expected space complexity of O(N) as at the worst case we stored all the airports in the queue at one time. When running the BFS on the entire dataset we got resonably fast performance given the large amount of data samples for both airports and routes. To confirm that BFS was working properly we created test cases. Before writing any test cases we drew out a a smaller subset of the actaul graph structure and verfied by hand the traversal. Once we created the graph by hand we then transfered this over to the respective csv files and wrote test cases to verify the correctness of the traversal. This worked very effectively and gave us confidence in our implementation of BFS. One misconception that we had about BFS before our implementation was that BFS was able to give us the shortest path of a graph. We quickly found out that although BFS does give us a spanning tree of a connected graph it does not however guarantee a minimal spanning tree. This is something we overlooked initially but were able to correct which was a good learning experience that helped us understand BFS more clearly.

### Dijkstra Algorithm

- The implementation of the Dijkstra Algorithm went as expected. We utilized a priority queue which gave us the desired time complexity of O((E+N)log(N)) where E is the number of routes and N is the number of airports. We also achieved the expected space comlexity of O(N) as at the worst case we stored all the airports in the priority queue at one time. When running the Dijkstra algorithm on the full dataset we were surprised on how fast the algorithm was able to output a shortest path given a source and destination airport. Although Dijkstra finds the shortest path from a source node to every other node in a graph we used a distance list as well as a previous list to keep track of each airports distance to the source airport and the airport visited before a given airport. These two lists (we used the standard unordered maps but for simplicity we can think of them as lists) allowed us to back track from the destination airport to the source airport to find our shortest path as well as the distance in kilometers to each respective airport. In terms of testing we took the same approach as in BFS by drawing out graphs by hand. The only difference here is that we were looking for the shortest path rather than a traversal and we also had to calculate the weights to help us to do this. We then transfered this into respective test csv files and checkout if the implementation outputed the same results.

### Bellman-Ford Algorithm

- The implementation of the Bellman-Ford Algorithm went as expected. Unlike BFS or Dijkstra, The Bellman-Ford Algorithm did not utilize a queue. The Bellman-Ford took a much simpler approach by overestimating the lenghs of each edge(route) and eventaully relaxing these nodes by traversing the edges N-1 times where N is the number of airports in the graph. Although this approach is a much simpler approach to find the shortest path from a source airport to every other airport its time compelexity is not the greatest being O(NE). We experienced the penalties of this time comlexity when running the Bellman-Ford algorithm on the entire dataset. The Bellman-Ford algorithm took an exceptionally longer time to run compared to Dijkstra or BFS. Although it did take longer to execute for large datasets, Bellman-Ford still outputed the same result as Dijkstra. Its interesting to see how these two algorithms were able to output the same result but with different approaches. This also proved to us the trade off between the complexity of an approach and the time complexity. Furthermore, we used the same approach as is Dijkstra and BFS to created test cases. We first drew out a graph by hand and used the algorithm to find the shortest path. We then transfered this into code which verified our implementation. We found this approach very effective as it allowed us to understand the algorithm better which in turn helped us find any mistakes in the code faster.

## The Answer to The Leading Question

-  Our leading question was how to find the shortest path between a source and destination airport given a graph structure of airports and routes provided by the OpenFlight dataset. We aimed to answer this question by implementing algorithms such as Dijkstra and Bellman-Ford as well as a BFS traversal. First, as we discorved through the process of working on the project that BFS did not guarantee a shortest path traversal. However, we did learn a lot from implementing the BFS on the OpenFlight dataset. One very interesting observation that we made was that when running BFS on different source airports the amount of airports that the traversal visited oftentimes remained the same. This showed us how connected each airport was in various parts of the graph. Its also important to note that although these traversal visited the same amount of airports the ordering in which they visited the airports did change. This showed us that the BFS traversal indeed took different paths in order to traverse the graph. Next, the Dijkstra algorithm successfully answered our leading question. After successfully implementing the dijkstra algorithm we were able to find shortest paths between source and destination airports in the OpenFlight dataset. This was a very exciting step in our project as Dijkstra was able to generate the shortest path alogrithm on the entire dataset very quickly. This gave us a good understanding of the possible ways applications that track flights might go about finding shortest path for their users. Finally, the Bellman-Ford algorithm successfully answered our leading question. Although exceptionally slower than the Dijkstra algorithm in finding the shortest path the Bellman-Ford also gave us a way to find the shortest path. Implementing Bellman-Ford alongside Dijkstra really helped us see the trade off between the comlexity of an approach an the time complexity as Bellman-Ford was easier to imlement, more intuitive but time costly. Overall we think that we did successfully answer the leading question we aimed to answer at the beginning and in the process we were able to have some important take aways of implementing a graph structure.